import { Injectable, EventEmitter } from '@angular/core';
import { FileState } from './file-info';
import { FileMap } from './file-map';
import { HttpClient, HttpRequest, HttpHeaders, HttpResponse, HttpEventType } from '@angular/common/http';
import { CancelEvent, ClearEvent, ErrorEvent, RemoveEvent, SelectEvent, SuccessEvent, UploadEvent, UploadProgressEvent } from './upload-events';
import util from "./util";
/**
 * @hidden
 */
var UploadService = /** @class */ (function () {
    function UploadService(http) {
        this.http = http;
        this.cancelEvent = new EventEmitter();
        this.clearEvent = new EventEmitter();
        this.completeEvent = new EventEmitter();
        this.errorEvent = new EventEmitter();
        this.removeEvent = new EventEmitter();
        this.selectEvent = new EventEmitter();
        this.successEvent = new EventEmitter();
        this.uploadEvent = new EventEmitter();
        this.uploadProgressEvent = new EventEmitter();
        // Required for the `ControlValueAccessor` integration
        this.changeEvent = new EventEmitter();
        this.fileList = new FileMap();
    }
    Object.defineProperty(UploadService.prototype, "files", {
        get: function () {
            return this.fileList;
        },
        enumerable: true,
        configurable: true
    });
    UploadService.prototype.onChange = function () {
        var files = this.fileList.filesFlat.filter(function (file) {
            return file.state === FileState.Initial ||
                file.state === FileState.Uploaded;
        });
        this.changeEvent.emit(files.length > 0 ? files : null);
    };
    UploadService.prototype.addFiles = function (files, async) {
        var selectEventArgs = new SelectEvent(files);
        this.selectEvent.emit(selectEventArgs);
        if (!selectEventArgs.isDefaultPrevented()) {
            for (var _i = 0, files_1 = files; _i < files_1.length; _i++) {
                var file = files_1[_i];
                this.fileList.add(file);
            }
            if (async.autoUpload) {
                this.uploadFiles(async);
            }
        }
    };
    UploadService.prototype.addInitialFiles = function (initialFiles) {
        var _this = this;
        this.fileList.clear();
        initialFiles.forEach(function (file) {
            var fakeFile = util.getInitialFileInfo(file);
            _this.fileList.add(fakeFile);
        });
    };
    UploadService.prototype.removeFiles = function (uid, async) {
        var removedFiles = this.fileList.get(uid);
        // Clone the Headers so that the default ones are not overridden
        var removeEventArgs = new RemoveEvent(removedFiles, this.cloneRequestHeaders(async.removeHeaders));
        this.removeEvent.emit(removeEventArgs);
        if (!removeEventArgs.isDefaultPrevented()) {
            if (removedFiles[0].state === FileState.Uploaded ||
                removedFiles[0].state === FileState.Initial) {
                this.performRemove(removedFiles, async, removeEventArgs);
            }
            else {
                this.fileList.remove(uid);
            }
        }
    };
    UploadService.prototype.cancelFiles = function (uid) {
        var canceledFiles = this.fileList.get(uid);
        var cancelEventArgs = new CancelEvent(canceledFiles);
        this.cancelEvent.emit(cancelEventArgs);
        for (var _i = 0, canceledFiles_1 = canceledFiles; _i < canceledFiles_1.length; _i++) {
            var file = canceledFiles_1[_i];
            if (file.httpSubscription) {
                file.httpSubscription.unsubscribe();
            }
        }
        this.fileList.remove(uid);
    };
    UploadService.prototype.clearFiles = function () {
        var clearEventArgs = new ClearEvent();
        this.clearEvent.emit(clearEventArgs);
        if (!clearEventArgs.isDefaultPrevented()) {
            var triggerChange = this.fileList.hasFileWithState([FileState.Initial, FileState.Uploaded]);
            this.fileList.clear();
            if (triggerChange) {
                this.onChange();
            }
        }
    };
    UploadService.prototype.uploadFiles = function (async) {
        var allFilesToUpload = this.fileList.filesToUpload;
        this._uploadFiles(allFilesToUpload, async);
    };
    UploadService.prototype.retryFiles = function (uid, async) {
        var filesToRetry = [this.fileList.get(uid)];
        this._uploadFiles(filesToRetry, async);
    };
    UploadService.prototype._uploadFiles = function (allFiles, async) {
        var _loop_1 = function (filesToUpload) {
            // Clone the Headers so that the default ones are not overridden
            var uploadEventArgs = new UploadEvent(filesToUpload, this_1.cloneRequestHeaders(async.saveHeaders));
            this_1.uploadEvent.emit(uploadEventArgs);
            if (!uploadEventArgs.isDefaultPrevented()) {
                this_1.fileList.setFilesState(filesToUpload, FileState.Uploading);
                var httpSubcription_1 = this_1.performUpload(filesToUpload, async, uploadEventArgs);
                filesToUpload.forEach(function (file) {
                    file.httpSubscription = httpSubcription_1;
                });
            }
            else {
                this_1.fileList.remove(filesToUpload[0].uid);
            }
        };
        var this_1 = this;
        for (var _i = 0, allFiles_1 = allFiles; _i < allFiles_1.length; _i++) {
            var filesToUpload = allFiles_1[_i];
            _loop_1(filesToUpload);
        }
    };
    UploadService.prototype.performRemove = function (files, async, removeEventArgs) {
        var _this = this;
        var fileNames = files.map(function (file) {
            return file.name;
        });
        var formData = this.populateRemoveFormData(fileNames, async.removeField, removeEventArgs.data);
        var options = this.populateRequestOptions(async, removeEventArgs.headers);
        var removeRequest = new HttpRequest(async.removeMethod, async.removeUrl, formData, options);
        this.http.request(removeRequest)
            .subscribe(function (success) {
            _this.onSuccess(success, files, "remove");
        }, function (error) {
            _this.onError(error, files, "remove");
        });
    };
    UploadService.prototype.performUpload = function (files, async, uploadEventArgs) {
        var _this = this;
        var formData = this.populateUploadFormData(files, async.saveField, uploadEventArgs.data);
        var options = this.populateRequestOptions(async, uploadEventArgs.headers);
        var uploadRequest = new HttpRequest(async.saveMethod, async.saveUrl, formData, options);
        var httpSubscription = this.http.request(uploadRequest)
            .subscribe(function (event) {
            if (event.type === HttpEventType.UploadProgress) {
                _this.onProgress(event, files);
            }
            else if (event instanceof HttpResponse) {
                _this.onSuccess(event, files, "upload");
                _this.checkAllComplete();
            }
        }, function (error) {
            _this.onError(error, files, "upload");
            _this.checkAllComplete();
        });
        return httpSubscription;
    };
    UploadService.prototype.onSuccess = function (successResponse, files, operation) {
        var successArgs = new SuccessEvent(files, operation, successResponse);
        this.successEvent.emit(successArgs);
        if (operation === "upload") {
            this.fileList.setFilesState(files, successArgs.isDefaultPrevented() ? FileState.Failed : FileState.Uploaded);
        }
        else {
            if (!successArgs.isDefaultPrevented()) {
                this.fileList.remove(files[0].uid);
            }
        }
        if (!successArgs.isDefaultPrevented()) {
            this.onChange();
        }
    };
    UploadService.prototype.onError = function (errorResponse, files, operation) {
        var errorArgs = new ErrorEvent(files, operation, errorResponse);
        this.errorEvent.emit(errorArgs);
        if (operation === "upload") {
            this.fileList.setFilesState(files, FileState.Failed);
        }
    };
    UploadService.prototype.onProgress = function (event, files) {
        var percentComplete = Math.round(100 * event.loaded / event.total);
        var progressArgs = new UploadProgressEvent(files, percentComplete < 100 ? percentComplete : 100);
        this.uploadProgressEvent.emit(progressArgs);
    };
    UploadService.prototype.checkAllComplete = function () {
        if (!this.fileList.hasFileWithState([FileState.Selected, FileState.Uploading])) {
            this.completeEvent.emit();
        }
    };
    UploadService.prototype.cloneRequestHeaders = function (headers) {
        var cloned = {};
        headers.keys().forEach(function (key) {
            cloned[key] = headers.get(key);
        });
        return new HttpHeaders(cloned);
    };
    UploadService.prototype.populateRequestOptions = function (async, headers) {
        return {
            headers: headers,
            reportProgress: true,
            responseType: async.responseType,
            withCredentials: async.withCredentials
        };
    };
    UploadService.prototype.populateUploadFormData = function (files, saveField, clientData) {
        var data = new FormData();
        this.populateClientFormData(data, clientData);
        for (var _i = 0, files_2 = files; _i < files_2.length; _i++) {
            var file = files_2[_i];
            data.append(saveField, file.rawFile);
        }
        return data;
    };
    UploadService.prototype.populateRemoveFormData = function (fileNames, removeField, clientData) {
        var data = new FormData();
        this.populateClientFormData(data, clientData);
        for (var _i = 0, fileNames_1 = fileNames; _i < fileNames_1.length; _i++) {
            var fileName = fileNames_1[_i];
            data.append(removeField, fileName);
        }
        return data;
    };
    UploadService.prototype.populateClientFormData = function (data, clientData) {
        for (var key in clientData) {
            if (clientData.hasOwnProperty(key)) {
                data.append(key, clientData[key]);
            }
        }
    };
    UploadService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    UploadService.ctorParameters = function () { return [
        { type: HttpClient, },
    ]; };
    return UploadService;
}());
export { UploadService };
