import { Injectable, EventEmitter } from '@angular/core';
import { FileState } from './file-info';
import { FileMap } from './file-map';
import { HttpClient, HttpRequest, HttpHeaders, HttpResponse, HttpEventType } from '@angular/common/http';
import { CancelEvent, ClearEvent, ErrorEvent, RemoveEvent, SelectEvent, SuccessEvent, UploadEvent, UploadProgressEvent } from './upload-events';
import util from "./util";
/**
 * @hidden
 */
export class UploadService {
    constructor(http) {
        this.http = http;
        this.cancelEvent = new EventEmitter();
        this.clearEvent = new EventEmitter();
        this.completeEvent = new EventEmitter();
        this.errorEvent = new EventEmitter();
        this.removeEvent = new EventEmitter();
        this.selectEvent = new EventEmitter();
        this.successEvent = new EventEmitter();
        this.uploadEvent = new EventEmitter();
        this.uploadProgressEvent = new EventEmitter();
        // Required for the `ControlValueAccessor` integration
        this.changeEvent = new EventEmitter();
        this.fileList = new FileMap();
    }
    get files() {
        return this.fileList;
    }
    onChange() {
        let files = this.fileList.filesFlat.filter((file) => {
            return file.state === FileState.Initial ||
                file.state === FileState.Uploaded;
        });
        this.changeEvent.emit(files.length > 0 ? files : null);
    }
    addFiles(files, async) {
        let selectEventArgs = new SelectEvent(files);
        this.selectEvent.emit(selectEventArgs);
        if (!selectEventArgs.isDefaultPrevented()) {
            for (let file of files) {
                this.fileList.add(file);
            }
            if (async.autoUpload) {
                this.uploadFiles(async);
            }
        }
    }
    addInitialFiles(initialFiles) {
        this.fileList.clear();
        initialFiles.forEach((file) => {
            let fakeFile = util.getInitialFileInfo(file);
            this.fileList.add(fakeFile);
        });
    }
    removeFiles(uid, async) {
        let removedFiles = this.fileList.get(uid);
        // Clone the Headers so that the default ones are not overridden
        let removeEventArgs = new RemoveEvent(removedFiles, this.cloneRequestHeaders(async.removeHeaders));
        this.removeEvent.emit(removeEventArgs);
        if (!removeEventArgs.isDefaultPrevented()) {
            if (removedFiles[0].state === FileState.Uploaded ||
                removedFiles[0].state === FileState.Initial) {
                this.performRemove(removedFiles, async, removeEventArgs);
            }
            else {
                this.fileList.remove(uid);
            }
        }
    }
    cancelFiles(uid) {
        let canceledFiles = this.fileList.get(uid);
        let cancelEventArgs = new CancelEvent(canceledFiles);
        this.cancelEvent.emit(cancelEventArgs);
        for (let file of canceledFiles) {
            if (file.httpSubscription) {
                file.httpSubscription.unsubscribe();
            }
        }
        this.fileList.remove(uid);
    }
    clearFiles() {
        let clearEventArgs = new ClearEvent();
        this.clearEvent.emit(clearEventArgs);
        if (!clearEventArgs.isDefaultPrevented()) {
            let triggerChange = this.fileList.hasFileWithState([FileState.Initial, FileState.Uploaded]);
            this.fileList.clear();
            if (triggerChange) {
                this.onChange();
            }
        }
    }
    uploadFiles(async) {
        let allFilesToUpload = this.fileList.filesToUpload;
        this._uploadFiles(allFilesToUpload, async);
    }
    retryFiles(uid, async) {
        let filesToRetry = [this.fileList.get(uid)];
        this._uploadFiles(filesToRetry, async);
    }
    _uploadFiles(allFiles, async) {
        for (let filesToUpload of allFiles) {
            // Clone the Headers so that the default ones are not overridden
            let uploadEventArgs = new UploadEvent(filesToUpload, this.cloneRequestHeaders(async.saveHeaders));
            this.uploadEvent.emit(uploadEventArgs);
            if (!uploadEventArgs.isDefaultPrevented()) {
                this.fileList.setFilesState(filesToUpload, FileState.Uploading);
                let httpSubcription = this.performUpload(filesToUpload, async, uploadEventArgs);
                filesToUpload.forEach((file) => {
                    file.httpSubscription = httpSubcription;
                });
            }
            else {
                this.fileList.remove(filesToUpload[0].uid);
            }
        }
    }
    performRemove(files, async, removeEventArgs) {
        let fileNames = files.map((file) => {
            return file.name;
        });
        let formData = this.populateRemoveFormData(fileNames, async.removeField, removeEventArgs.data);
        let options = this.populateRequestOptions(async, removeEventArgs.headers);
        let removeRequest = new HttpRequest(async.removeMethod, async.removeUrl, formData, options);
        this.http.request(removeRequest)
            .subscribe(success => {
            this.onSuccess(success, files, "remove");
        }, error => {
            this.onError(error, files, "remove");
        });
    }
    performUpload(files, async, uploadEventArgs) {
        let formData = this.populateUploadFormData(files, async.saveField, uploadEventArgs.data);
        let options = this.populateRequestOptions(async, uploadEventArgs.headers);
        let uploadRequest = new HttpRequest(async.saveMethod, async.saveUrl, formData, options);
        let httpSubscription = this.http.request(uploadRequest)
            .subscribe(event => {
            if (event.type === HttpEventType.UploadProgress) {
                this.onProgress(event, files);
            }
            else if (event instanceof HttpResponse) {
                this.onSuccess(event, files, "upload");
                this.checkAllComplete();
            }
        }, error => {
            this.onError(error, files, "upload");
            this.checkAllComplete();
        });
        return httpSubscription;
    }
    onSuccess(successResponse, files, operation) {
        const successArgs = new SuccessEvent(files, operation, successResponse);
        this.successEvent.emit(successArgs);
        if (operation === "upload") {
            this.fileList.setFilesState(files, successArgs.isDefaultPrevented() ? FileState.Failed : FileState.Uploaded);
        }
        else {
            if (!successArgs.isDefaultPrevented()) {
                this.fileList.remove(files[0].uid);
            }
        }
        if (!successArgs.isDefaultPrevented()) {
            this.onChange();
        }
    }
    onError(errorResponse, files, operation) {
        let errorArgs = new ErrorEvent(files, operation, errorResponse);
        this.errorEvent.emit(errorArgs);
        if (operation === "upload") {
            this.fileList.setFilesState(files, FileState.Failed);
        }
    }
    onProgress(event, files) {
        const percentComplete = Math.round(100 * event.loaded / event.total);
        const progressArgs = new UploadProgressEvent(files, percentComplete < 100 ? percentComplete : 100);
        this.uploadProgressEvent.emit(progressArgs);
    }
    checkAllComplete() {
        if (!this.fileList.hasFileWithState([FileState.Selected, FileState.Uploading])) {
            this.completeEvent.emit();
        }
    }
    cloneRequestHeaders(headers) {
        let cloned = {};
        headers.keys().forEach((key) => {
            cloned[key] = headers.get(key);
        });
        return new HttpHeaders(cloned);
    }
    populateRequestOptions(async, headers) {
        return {
            headers: headers,
            reportProgress: true,
            responseType: async.responseType,
            withCredentials: async.withCredentials
        };
    }
    populateUploadFormData(files, saveField, clientData) {
        let data = new FormData();
        this.populateClientFormData(data, clientData);
        for (let file of files) {
            data.append(saveField, file.rawFile);
        }
        return data;
    }
    populateRemoveFormData(fileNames, removeField, clientData) {
        let data = new FormData();
        this.populateClientFormData(data, clientData);
        for (let fileName of fileNames) {
            data.append(removeField, fileName);
        }
        return data;
    }
    populateClientFormData(data, clientData) {
        for (var key in clientData) {
            if (clientData.hasOwnProperty(key)) {
                data.append(key, clientData[key]);
            }
        }
    }
}
UploadService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
UploadService.ctorParameters = () => [
    { type: HttpClient, },
];
