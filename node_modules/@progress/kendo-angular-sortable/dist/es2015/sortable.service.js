import { Injectable } from '@angular/core';
/**
 * The service that provides the drag-and-drop functionality for
 * transferring items between Sortable components within the same page.
 *
 * @hidden
 */
export class SortableService {
    constructor() {
        this.source = null;
        this.previous = null;
        this.sortableCounter = 0;
        this.sortableRegister = {};
    }
    /**
     * Registers a `SortableComponent` with which the service operates.
     *
     * @param sortableComponent - The `SortableComponent`.
     * @return - The unique key that the current `SortableComponent` gets when registered.
     */
    registerComponent(sortableComponent) {
        const id = this.sortableCounter.toString();
        this.sortableRegister[id] = sortableComponent;
        this.sortableCounter++;
        return id;
    }
    /**
     * Removes a `SortableComponent` from the registered `SortableComponents` with which the service operates.
     *
     * @param key - The key of the `SortableComponent` which will be removed from the register.
     * Obtained when `registerComponent` is called.
     */
    unregisterComponent(key) {
        this.sortableRegister[key] = null;
    }
    /**
     * Sets the `SortableComponent` as a source component. When dragging an item from one Sortable to another,
     * the source component is the one from which the item originates.
     *
     * @param sortable - The `SortableComponent`.
     */
    setSource(sortable) {
        this.source = sortable;
    }
    /**
     * Returns the source `SortableComponent` from which
     * an item is dragged to other Sortable components.
     *
     * @return - The `SourceComponent`.
     */
    getSource() {
        return this.source;
    }
    /**
     * Called by the `SortableComponents` when an item is dragged from one Sortable to another.
     *
     * @param target - The target `SortableComponent`.
     * @param index - The index of the item that is dragged.
     */
    initMove(target, index) {
        if (target !== this.previous) {
            if (this.previous) {
                this.previous.removeActiveItem();
                this.previous = null;
            }
            if (target === this.source) {
                this.source.hideActiveItem = false;
            }
            else {
                target.addDataItem(this.source.getActiveItem(), index);
                this.source.hideActiveItem = true;
                this.previous = target;
            }
        }
    }
    /**
     * Called by the `SortableComponent` when the dragging of an item is completed.
     *
     * @param target - The target Sortable component where the item is dropped.
     */
    finishMove() {
        if (this.previous && this.source) {
            this.previous.clearActiveItem();
            this.source.hideActiveItem = false;
            this.source.removeActiveItem();
        }
        this.previous = null;
        this.source = null;
    }
    /**
     * The method that finds the `SortableComponent` which is registered to
     * the `SortableService` by using the arguments of the `touch` event.
     *
     * @param touch - A Touch-Object of the `Touch` type interface.
     * Represents a single contact point (finger or stylus)
     * on a touch-sensitive device (touchscreen or trackpad).
     *
     * @return { component: SortableComponent, index: number } - An object
     * where the component is the `SortableComponent` that owns the item
     * and the index is the index of the touched item.
     */
    getSortableComponentFromTouch(touch) {
        let realTarget = document.elementFromPoint(touch.clientX, touch.clientY);
        while (realTarget) {
            const id = realTarget.getAttribute('data-sortable-id');
            const index = realTarget.getAttribute('data-sortable-index');
            if (id) {
                const targetSortable = this.sortableRegister[id];
                if (targetSortable) {
                    return { component: targetSortable, index: parseInt(index, 10) };
                }
            }
            realTarget = realTarget.parentElement;
        }
    }
}
SortableService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
SortableService.ctorParameters = () => [];
