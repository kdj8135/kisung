import { Component, Input, Output, ContentChild, ViewChildren, TemplateRef, EventEmitter, Inject, Optional, HostBinding } from '@angular/core';
import { RTL } from '@progress/kendo-angular-l10n';
import { DataEvent } from './drag-event-args.interface';
import { SortableService } from './sortable.service';
/**
 * Represents the Kendo UI Sortable component for Angular.
 *
 * {% embed_file sortable-api/app.component.ts %}
 * {% embed_file shared/app.module.ts preview %}
 * {% embed_file shared/main.ts hidden %}
 */
/**
 * Represents the Kendo UI Sortable component for Angular.
 */
var SortableComponent = /** @class */ (function () {
    function SortableComponent(sortableService, rtl) {
        /**
         * Specifies the tab index of the Sortable component.
         */
        this.tabIndex = null;
        /**
         * Sets an array of any data that is used as a data source for the Sortable.
         *
         * {% embed_file sortable-palettes/app.component.ts %}
         * {% embed_file shared/app.module.ts %}
         * {% embed_file shared/main.ts hidden %}
         */
        this.data = [];
        /**
         * Enables or disables the [keyboard navigation]({% slug keyboard_navigation_sortable %}).
         * The default value is `false`.
         */
        this.navigatable = false;
        /**
         * Enables or disables the built-in animations.
         * The default value is `false`.
         */
        this.animation = false;
        /**
         * Sets an array of integers, which represent the indexes of the disabled items from the data array.
         * For more information, refer to the section on
         * [disabled items]({% slug overview_sortable %}#toc-disabled-items).
         */
        this.disabledIndexes = [];
        /**
         * Sets a string that represents the name of the zone to which the Sortable belongs.
         * Items can be transferred between Sortables which belong to the same zone.
         * For more information, refer to the section on
         * [transferring items]({% slug overview_sortable %}#toc-transfer-of-items).
         */
        this.zone = undefined;
        /**
         * Defines the zones from which items can be transferred onto the current Sortable component.
         * If the `acceptZones` property of the target Sortable is set, allows you to transfer items between Sortables
         * which belong to different zones.
         * For more information, refer to the section on the
         * [transfer of items]({% slug overview_sortable %}#toc-transfer-of-items).
         */
        this.acceptZones = undefined;
        /**
         * Represents the CSS styles which are applied to each Sortable item.
         *
         * @example
         * ```ts
         * import { Component } from '@angular/core';
         * import { SortableModule } from '@progress/kendo-angular-sortable';
         *
         * _@Component({
         *  selector: 'my-app',
         *  template: `
         *   <kendo-sortable
         *      [data]="['1','2','3','4','5','6','7']"
         *      [itemStyle] ="{
         *          'display': 'inline-block',
         *          'background-color': '#51A0ED',
         *          'height':'50px',
         *          'width':'50px',
         *          'margin':'3px',
         *          'cursor':'move'
         *          }"
         *      >
         *   </kendo-sortable>
         *    `
         * })
         * export class AppComponent {
         * }
         * ```
         */
        this.itemStyle = {};
        /**
         * Defines the CSS styles applied to an empty item.
         */
        this.emptyItemStyle = undefined;
        /**
         * Defines the CSS styles which are applied to the currently dragged item.
         */
        this.activeItemStyle = undefined;
        /**
         * Defines the CSS styles which are applied to all disabled items.
         */
        this.disabledItemStyle = undefined;
        /**
         * Defines the class which is applied to each Sortable item.
         */
        this.itemClass = "";
        /**
         * Defines the class which is applied to the active Sortable item.
         */
        this.activeItemClass = null;
        /**
         * Defines the class which is applied to the empty item when the Sortable has empty data.
         */
        this.emptyItemClass = null;
        /**
         * Defines the class which is applied to each disabled Sortable item.
         */
        this.disabledItemClass = null;
        /**
         * Sets the text message that will be displayed when the Sortable has no items.
         *
         * @example
         * ```ts
         * import { Component } from '@angular/core';
         * import { SortableModule } from '@progress/kendo-angular-sortable';
         *
         * _@Component({
         *  selector: 'my-app',
         *  template: `
         *    <kendo-sortable [data]="[]"
         *      [emptyText]="'No items - custom message and styles'"
         *      [emptyItemStyle] = "{'height': '40px', 'width':'400px', 'border': '2px dashed black'}" >
         *    </kendo-sortable>
         *    `
         * })
         * export class AppComponent { }
         * ```
         */
        this.emptyText = "Empty";
        /**
         * Defines the template that will be used for rendering the items.
         */
        this.itemTemplateRef = null;
        this.itemWrappers = null;
        /**
         * Fires when the dragging of an item is started.
         */
        this.dragStart = new EventEmitter();
        /**
         * Fires when the dragging of an item is completed.
         */
        this.dragEnd = new EventEmitter();
        /**
         * Fires while the dragging of an item is in progress.
         */
        this.dragOver = new EventEmitter();
        /**
         * Fires when a new item is added to the Sortable.
         */
        this.dataAdd = new EventEmitter();
        /**
         * Fires when an item is removed from the Sortable.
         */
        this.dataRemove = new EventEmitter();
        /**
         * The index of the currently focused item.
         * If no item is focused, set to `-1`.
         */
        this.activeIndex = -1;
        /**
         * The location of the hint indicator when dragging on mobile devices.
         */
        this.hintLocation = null;
        this.afterKeyPress = false;
        this.transferService = null;
        this._hideActiveItem = false;
        this.animating = false;
        this.direction = rtl ? 'rtl' : 'ltr';
        this.transferService = sortableService;
    }
    SortableComponent.prototype.ngOnInit = function () {
        if (!this.data) {
            this.data = [];
        }
        this.id = this.transferService.registerComponent(this);
        this.dragIndex = -1;
        var display = "display";
        if (this.activeItemStyle && !this.activeItemStyle[display]) {
            this.activeItemStyle[display] = "";
        }
        if (!this.itemStyle[display]) {
            this.itemStyle[display] = "";
        }
    };
    SortableComponent.prototype.ngOnDestroy = function () {
        this.transferService.unregisterComponent(this.id);
        this.transferService = null;
    };
    SortableComponent.prototype.ngAfterViewChecked = function () {
        if (this.afterKeyPress) {
            if (this.itemWrappers) {
                var elems = this.itemWrappers.toArray();
                if (elems && elems.length > 0 && this.activeIndex > -1) {
                    elems[this.activeIndex].nativeElement.focus();
                }
            }
            this.afterKeyPress = false;
        }
    };
    /**
     * @hidden
     */
    SortableComponent.prototype.currentItemStyle = function (index) {
        if (index === -1) {
            return this.emptyItemStyle ? this.emptyItemStyle : this.itemStyle;
        }
        if (!this.itemEnabled(index) && this.disabledItemStyle) {
            return this.disabledItemStyle;
        }
        if (index === this.dragIndex || (this.dragIndex === -1 && index === this.activeIndex)) {
            if (this.hideActiveItem) {
                return { "display": "none" };
            }
            if (this.activeItemStyle) {
                return this.activeItemStyle;
            }
        }
        return this.itemStyle;
    };
    /**
     * @hidden
     */
    SortableComponent.prototype.currentItemClass = function (index) {
        if (index === -1) {
            return this.emptyItemClass ? this.emptyItemClass : this.itemClass;
        }
        if (!this.itemEnabled(index) && this.disabledItemClass) {
            return this.disabledItemClass;
        }
        if ((index === this.dragIndex || this.dragIndex === -1 && index === this.activeIndex) && this.activeItemClass) {
            return this.activeItemClass;
        }
        return this.itemClass;
    };
    /**
     * @hidden
     */
    SortableComponent.prototype.hintStyle = function () {
        var style = {
            "left": this.hintLocation.x + 10 + "px",
            "position": "absolute",
            "top": this.hintLocation.y + 10 + "px"
        };
        return style;
    };
    /**
     * @hidden
     */
    SortableComponent.prototype.itemEnabled = function (index) {
        return this.disabledIndexes.indexOf(index) === -1;
    };
    /**
     * @hidden
     */
    SortableComponent.prototype.acceptDragFrom = function (sortableComponent) {
        if (this.zone === undefined || !sortableComponent) {
            return false;
        }
        if (this.acceptZones === undefined) {
            return (this.zone === sortableComponent.zone);
        }
        else if (sortableComponent.zone !== undefined) {
            return (this.acceptZones.indexOf(sortableComponent.zone) !== -1);
        }
        return false;
    };
    /**
     * @hidden
     */
    SortableComponent.prototype.ariaDropEffect = function (index) {
        return this.itemEnabled(index) ? "move" : "none";
    };
    /**
     * @hidden
     */
    SortableComponent.prototype.dragStartHandler = function (event, index) {
        if (this.itemEnabled(index)) {
            event.dataTransfer.setData("text", "");
        }
        this.touchStart(event, index);
    };
    /**
     * @hidden
     */
    SortableComponent.prototype.focusHandler = function (index) {
        if (this.navigatable) {
            this.activeIndex = index;
        }
    };
    /**
     * @hidden
     */
    SortableComponent.prototype.blurHandler = function () {
        if (this.navigatable && !this.afterKeyPress) {
            this.activeIndex = -1;
        }
    };
    /**
     * @hidden
     */
    SortableComponent.prototype.keydownHandler = function (event) {
        var code = event.keyCode;
        var navigate = this.navigatable && code >= 37 && code <= 40;
        var hasFocus = this.activeIndex !== -1;
        if (!navigate || !hasFocus) {
            return;
        }
        var leftKey = this.direction === 'rtl' ? 39 : 37;
        var dir = code === 38 || code === leftKey ? -1 : 1;
        var limit = this.data.length - 1;
        var targetIndex = this.activeIndex + dir;
        while (!this.itemEnabled(targetIndex) && targetIndex <= limit) {
            targetIndex += dir;
        }
        targetIndex = Math.min(Math.max(targetIndex, 0), limit);
        if (!this.itemEnabled(targetIndex)) {
            return;
        }
        var ctrl = event.ctrlKey || event.metaKey;
        var shouldDrag = ctrl && navigate;
        if (shouldDrag) {
            this.dragIndex = this.activeIndex;
            this.moveCurrentItemTo(targetIndex);
            this.activeIndex = this.dragIndex;
            this.dragIndex = -1;
        }
        else {
            this.activeIndex = targetIndex;
        }
        event.stopPropagation();
        event.preventDefault();
        this.afterKeyPress = true;
    };
    /**
     * @hidden
     */
    SortableComponent.prototype.touchStart = function (event, index) {
        if (this.itemEnabled(index)) {
            event.stopPropagation();
            this.dragIndex = index;
            this.dragStart.emit({ index: index });
            this.transferService.setSource(this);
        }
        else {
            event.preventDefault();
        }
    };
    /**
     * @hidden
     */
    SortableComponent.prototype.dragStartPrevent = function (event) {
        event.dataTransfer.setData("text", "");
        this.touchStartPrevent(event);
    };
    /**
     * @hidden
     */
    SortableComponent.prototype.touchStartPrevent = function (event) {
        event.stopPropagation();
        event.preventDefault();
    };
    /**
     * @hidden
     */
    SortableComponent.prototype.dragOverHandler = function (event, index) {
        this.handleMove(event, index);
    };
    /**
     * @hidden
     */
    SortableComponent.prototype.touchMove = function (event) {
        var touch = event.changedTouches[0];
        this.hintLocation = { x: touch.pageX, y: touch.pageY };
        var target = this.transferService.getSortableComponentFromTouch(touch);
        if (target && target.component) {
            target.component.handleMove(event, target.index);
        }
    };
    Object.defineProperty(SortableComponent.prototype, "dir", {
        get: function () {
            return this.direction;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Removes the currently active item from the Data collection that the Sortable uses.
     */
    SortableComponent.prototype.removeActiveItem = function () {
        if (this.dragIndex >= 0) {
            var dataRemoveArgs = new DataEvent(this.dragIndex, this.data[this.dragIndex]);
            this.dataRemove.emit(dataRemoveArgs);
            var i = this.dragIndex + 1;
            this.dragIndex = -1;
            if (!dataRemoveArgs.isDefaultPrevented()) {
                for (; i < this.data.length; i++) {
                    this.data[i - 1] = this.data[i];
                }
                this.data.pop();
            }
        }
    };
    Object.defineProperty(SortableComponent.prototype, "hideActiveItem", {
        /**
         * If the currently dragged item is hidden, returns `true`.
         * If the currently dragged item is visible, returns `false`.
         */
        get: function () {
            return this._hideActiveItem;
        },
        /**
         * Sets a Boolean value that indicates whether the currently dragged item will be hidden.
         */
        set: function (value) {
            this.activeIndex = -1;
            this._hideActiveItem = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Clears the active item.
     * An active item is the item which becomes focused when the user navigates with the keyboard.
     */
    SortableComponent.prototype.clearActiveItem = function () {
        if (this.navigatable) {
            this.fixFocus();
        }
        this.dragIndex = -1;
    };
    /**
     * Returns the currently active item when the user navigates with the keyboard.
     * @return - The data item which is currently active.
     */
    SortableComponent.prototype.getActiveItem = function () {
        if (this.data && this.dragIndex >= 0 && this.dragIndex < this.data.length) {
            return this.data[this.dragIndex];
        }
    };
    /**
     * Adds a new data item to a particular index.
     * @param dataItem - The data item.
     * @param index - The index at which the data item is inserted.
     */
    SortableComponent.prototype.addDataItem = function (dataItem, index) {
        var dataAddArgs = new DataEvent(index, dataItem);
        this.dataAdd.emit(dataAddArgs);
        if (!dataAddArgs.isDefaultPrevented()) {
            this.data.push(dataItem);
            this.dragIndex = this.data.length - 1;
            this.moveCurrentItemTo(index);
        }
    };
    /**
     * @hidden
     */
    SortableComponent.prototype.moveCurrentItemTo = function (index) {
        var _this = this;
        if (index === this.dragIndex || !this.itemEnabled(index)) {
            return;
        }
        var dragIndex = this.dragIndex;
        this.dragIndex = -1;
        var d = index > dragIndex ? 1 : -1;
        var data = this.data;
        var tmp = data[dragIndex];
        var originalIndexAnimate = dragIndex;
        var toAnimate = [];
        var prevIndex = dragIndex;
        while (dragIndex !== index) {
            dragIndex += d;
            if (this.itemEnabled(dragIndex)) {
                data[prevIndex] = data[dragIndex];
                if (this.animation) {
                    toAnimate.push({ next: dragIndex, prev: prevIndex });
                }
                prevIndex = dragIndex;
            }
        }
        data[dragIndex] = tmp;
        if (this.animation) {
            toAnimate.push({ next: originalIndexAnimate, prev: dragIndex });
            setTimeout(function () { return _this.animate(toAnimate); });
        }
        this.dragIndex = dragIndex;
    };
    /**
     * @hidden
     */
    SortableComponent.prototype.animate = function (wrappers) {
        var itemArray = this.itemWrappers.toArray();
        var prevClientRect = [];
        var nextClientRect = [];
        var that = this;
        this.animating = true;
        for (var i = 0; i < wrappers.length; i++) {
            prevClientRect.push(itemArray[wrappers[i].prev].nativeElement.getBoundingClientRect());
            nextClientRect.push(itemArray[wrappers[i].next].nativeElement.getBoundingClientRect());
        }
        for (var i = 0; i < wrappers.length; i++) {
            var nextIndex = wrappers[i].prev;
            var targetRect = nextClientRect[i];
            var currentRect = prevClientRect[i];
            var target = itemArray[nextIndex].nativeElement;
            this.applyAnimationStyle(target, 'transition', 'none');
            this.applyAnimationStyle(target, 'transform', 'translate3d('
                + (targetRect.left - currentRect.left).toString() + 'px,'
                + (targetRect.top - currentRect.top).toString() + 'px,0)');
            this.reflow(target);
        }
        var _loop_1 = function (i) {
            var nextIndex = wrappers[i].prev;
            var target = itemArray[nextIndex].nativeElement;
            this_1.applyAnimationStyle(target, 'transition', 'all ' + 300 + 'ms');
            this_1.applyAnimationStyle(target, 'transform', 'translate3d(0,0,0)');
            clearTimeout(target.animated);
            target.animated = setTimeout(function () {
                that.applyAnimationStyle(target, 'transition', '');
                that.applyAnimationStyle(target, 'transform', '');
                target.animated = false;
            }, 300);
        };
        var this_1 = this;
        for (var i = 0; i < wrappers.length; i++) {
            _loop_1(i);
        }
        setTimeout(function () { that.animating = false; }, 150);
    };
    /**
     * @hidden
     */
    SortableComponent.prototype.reflow = function (element) {
        return element.offsetWidth;
    };
    /**
     * @hidden
     */
    SortableComponent.prototype.applyAnimationStyle = function (el, prop, val) {
        var style = el && el.style;
        if (style) {
            if (!(prop in style)) {
                prop = '-webkit-' + prop;
            }
            style[prop] = val;
        }
    };
    /**
     * @hidden
     */
    SortableComponent.prototype.dragFinishHandler = function (event) {
        if (event.type === "dragend") {
            this.dragEnd.emit({ index: this.dragIndex });
        }
        this.handleDrop();
    };
    /**
     * @hidden
     */
    SortableComponent.prototype.touchFinish = function (event) {
        this.hintLocation = null;
        var target = this.transferService.getSortableComponentFromTouch(event.changedTouches[0]);
        if (target && target.component) {
            target.component.dragEnd.emit({ index: target.index });
            target.component.handleDrop();
        }
        else {
            this.dragEnd.emit({ index: this.dragIndex });
        }
        this.handleDrop();
    };
    SortableComponent.prototype.handleMove = function (event, index) {
        if (this.itemEnabled(index) && !this.animating) {
            if (this.acceptDragFrom(this.transferService.getSource())) {
                this.transferService.initMove(this, index);
            }
            if (this.dragIndex >= 0) {
                this.dragOver.emit({ newIndex: index, oldIndex: this.dragIndex });
                this.moveCurrentItemTo(index);
                event.preventDefault();
            }
        }
    };
    SortableComponent.prototype.handleDrop = function () {
        this.transferService.finishMove();
        if (this.navigatable) {
            this.fixFocus();
        }
        this.dragIndex = -1;
    };
    SortableComponent.prototype.fixFocus = function () {
        if (this.itemWrappers) {
            var itemArray = this.itemWrappers.toArray();
            if (this.dragIndex > -1 && itemArray && itemArray.length > 0) {
                itemArray[this.dragIndex].nativeElement.focus();
                this.activeIndex = this.dragIndex;
            }
        }
    };
    SortableComponent.decorators = [
        { type: Component, args: [{
                    exportAs: 'kendoSortable',
                    selector: 'kendo-sortable',
                    template: "<div #itemWrapper *ngFor=\"let item of data;let i=index\"\n    [ngStyle]=\"currentItemStyle(i)\"\n    [ngClass] = \"currentItemClass(i)\"\n    [draggable]=\"itemEnabled(i)\"\n    [attr.aria-disabled]=\"!itemEnabled(i)\"\n    [attr.aria-grabbed]=\"i===dragIndex\"\n    [attr.aria-dropeffect]=\"ariaDropEffect(i)\"\n    [attr.tabIndex]=\"itemEnabled(i)?(navigatable?tabIndex||0:tabIndex):null\"\n    (focus)=\"focusHandler(i)\"\n    (blur)=\"blurHandler()\"\n    (keydown)=\"keydownHandler($event)\"\n    (dragstart)=\"dragStartHandler($event,i)\"\n    (dragover)=\"dragOverHandler($event,i)\"\n    (dragend)=\"dragFinishHandler($event)\"\n    (drop)=\"dragFinishHandler($event)\"\n\n    (touchstart)=\"touchStart($event , i)\"\n    (touchmove)=\"touchMove($event)\"\n    (touchend)=\"touchFinish($event)\"\n    (touchcancel)=\"touchFinish($event)\"\n    [attr.data-sortable-index]=\"i\"\n    [attr.data-sortable-id]=\"id\">\n\n      <ng-template [ngIf]=\"itemTemplateRef\"\n        [ngTemplateOutlet]=\"itemTemplateRef\"\n        [ngTemplateOutletContext]=\"{item: item, index: i, active: i===dragIndex, disabled: !itemEnabled(i)}\">\n      </ng-template>\n      <ng-template [ngIf]=\"!itemTemplateRef\">{{item}}</ng-template>\n    </div>\n\n    <ng-template [ngIf]=\"!data.length || data.length === 1 && hideActiveItem\">\n        <div [ngStyle]=\"currentItemStyle(-1)\"\n        [ngClass] = \"currentItemClass(-1)\"\n        [draggable]=\"true\"\n        [attr.data-sortable-index]=\"0\"\n        [attr.data-sortable-id]=\"id\"\n        (dragstart)=\"dragStartPrevent($event)\"\n        (touchstart)=\"touchStartPrevent($event)\"\n        (dragover)=\"dragOverHandler($event,0)\">{{emptyText}}</div>\n    </ng-template>\n    <div *ngIf=\"dragIndex>=0 && hintLocation\" [ngStyle] = \"hintStyle()\">\n        <div [ngStyle]=\"currentItemStyle(dragIndex)\" [ngClass]=\"currentItemClass(dragIndex)\">\n            <ng-template [ngIf]=\"itemTemplateRef\"\n                [ngTemplateOutlet]=\"itemTemplateRef\"\n                [ngTemplateOutletContext]=\"{item: data[dragIndex]}\">\n            </ng-template>\n            <ng-template [ngIf]=\"!itemTemplateRef\">{{data[dragIndex]}}</ng-template>\n        </div>\n    </div>\n  "
                },] },
    ];
    /** @nocollapse */
    SortableComponent.ctorParameters = function () { return [
        { type: SortableService, },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [RTL,] },] },
    ]; };
    SortableComponent.propDecorators = {
        'tabIndex': [{ type: Input },],
        'data': [{ type: Input },],
        'navigatable': [{ type: Input },],
        'animation': [{ type: Input },],
        'disabledIndexes': [{ type: Input },],
        'zone': [{ type: Input },],
        'acceptZones': [{ type: Input },],
        'itemStyle': [{ type: Input },],
        'emptyItemStyle': [{ type: Input },],
        'activeItemStyle': [{ type: Input },],
        'disabledItemStyle': [{ type: Input },],
        'itemClass': [{ type: Input },],
        'activeItemClass': [{ type: Input },],
        'emptyItemClass': [{ type: Input },],
        'disabledItemClass': [{ type: Input },],
        'emptyText': [{ type: Input },],
        'itemTemplateRef': [{ type: ContentChild, args: [TemplateRef,] },],
        'itemWrappers': [{ type: ViewChildren, args: ['itemWrapper',] },],
        'dragStart': [{ type: Output },],
        'dragEnd': [{ type: Output },],
        'dragOver': [{ type: Output },],
        'dataAdd': [{ type: Output },],
        'dataRemove': [{ type: Output },],
        'activeIndex': [{ type: Input },],
        'dir': [{ type: HostBinding, args: ['attr.dir',] },],
    };
    return SortableComponent;
}());
export { SortableComponent };
