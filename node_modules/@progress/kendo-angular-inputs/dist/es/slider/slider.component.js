import { Renderer2, Component, ElementRef, EventEmitter, HostBinding, HostListener, Inject, Input, Optional, Output, ViewChild, forwardRef } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { Subscription } from 'rxjs/Subscription';
import { fromEvent } from 'rxjs/observable/fromEvent';
import { interval } from 'rxjs/observable/interval';
import { merge } from 'rxjs/observable/merge';
import { filter } from 'rxjs/operators/filter';
import { concatMap } from 'rxjs/operators/concatMap';
import { startWith } from 'rxjs/operators/startWith';
import { takeUntil } from 'rxjs/operators/takeUntil';
import { SliderUtil as Util, SliderModel } from '@telerik/kendo-inputs-common';
import { L10N_PREFIX, LocalizationService, RTL } from '@progress/kendo-angular-l10n';
import { Keys } from '../common/enums';
import { isChanged } from '../common/changes';
import { isButton, isDocumentAvailable, eventValue, decreaseValueToStep, increaseValueToStep } from './utils';
import { guid } from '../common/dom-utils';
/**
 * Represents the Kendo UI Slider component for Angular.
 */
var SliderComponent = /** @class */ (function () {
    function SliderComponent(localizationService, renderer, hostElement, rtl) {
        var _this = this;
        this.localizationService = localizationService;
        this.renderer = renderer;
        this.hostElement = hostElement;
        this.rtl = rtl;
        /**
         * @hidden
         */
        this.id = guid();
        /**
         * Makes the Slider side arrow buttons appear. When set to `false`, the buttons are not displayed.
         */
        this.showButtons = true;
        /**
         * Denotes the location of the tick marks in the Slider.
         *
         * The available options are:
         *   * `before`&mdash;Tick marks are located to the top side of the horizontal track or to the left side of a vertical track.
         *   * `after`&mdash;Tick marks are located to the bottom side of the horizontal track or to the right side of the vertical track.
         *   * `both`&mdash;Tick marks are located on both sides of the track.
         *   * `none`&mdash;Tick marks are not visible. The actual elements are not added to the DOM tree.
         */
        this.tickPlacement = 'both';
        /**
         * Defines the title of the ticks. The default title for each tick is its Slider value.
         * If a callback function is used, it accepts an argument holding the value of the component and returns a string with the new title.
         */
        this.title = Util.identity;
        /**
         * If set to `true`, it changes the orientation of the Slider from horizontal to vertical.
         */
        this.vertical = false;
        /**
         * The minimum value of the Slider. The attribute accepts both integers and floating-point numbers.
         */
        this.min = 0;
        /**
         * The maximum value of the Slider. The attribute accepts both integers and floating-point numbers.
         */
        this.max = 10;
        /**
         * The step value of the Slider. The attribute accepts only positive numbers. Can be both integer or a float number.
         */
        this.smallStep = 1;
        /**
         * If set to `true`, it disables the Slider.
         */
        this.disabled = false;
        /**
         * The current value of the Slider when initially displayed.
         * The component can use either the `value` binging or `NgModel`, but not both of them at the same time.
         */
        this.value = 0;
        /**
         * Specifies the [`tabindex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.
         */
        this.tabindex = 0;
        /**
         * Fires each time the user focuses the input element.
         */
        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the input element gets blurred.
         */
        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename
        /**
         * Fires each time the user selects a new value.
         */
        this.valueChange = new EventEmitter();
        this.dragging = false;
        this.decreaseButtonSubscription = Subscription.EMPTY;
        this.increaseButtonSubscription = Subscription.EMPTY;
        /**
         * @hidden
         */
        this.ifEnabled = function (callback, event) {
            if (!_this.disabled) {
                callback.call(_this, event);
            }
        };
        this.ngChange = function (_) { };
        this.ngTouched = function () { };
        this.decreaseValue = function () {
            _this.changeValue(decreaseValueToStep(_this.value, _this.getProps()));
        };
        this.increaseValue = function () {
            _this.changeValue(increaseValueToStep(_this.value, _this.getProps()));
        };
        this.direction = rtl ? 'rtl' : 'ltr';
        this.hostElement = hostElement.nativeElement;
    }
    Object.defineProperty(SliderComponent.prototype, "tabIndex", {
        get: function () {
            return this.tabindex;
        },
        /**
         * @hidden
         */
        set: function (tabIndex) {
            this.tabindex = tabIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "horizontalClass", {
        get: function () {
            return !this.vertical;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "verticalClass", {
        get: function () {
            return this.vertical;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "sliderClass", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "transitionsClass", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "widgetClass", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "stateDefaultClass", {
        get: function () {
            return true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "disabledClass", {
        get: function () {
            return this.disabled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "focusedClass", {
        get: function () {
            return this.focused;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "ariaDisabled", {
        get: function () {
            return this.disabled ? true : undefined;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "ariaMin", {
        get: function () {
            return this.min;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "ariaMax", {
        get: function () {
            return this.max;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "ariaValue", {
        get: function () {
            return this.value ? this.value : this.min;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "reverse", {
        get: function () {
            return this.rtl && !this.vertical;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "keyBinding", {
        get: function () {
            var reverse = this.reverse;
            var increment = function (_a) {
                var value = _a.value, smallStep = _a.smallStep;
                return value + smallStep;
            };
            var decrement = function (_a) {
                var value = _a.value, smallStep = _a.smallStep;
                return value - smallStep;
            };
            return _a = {},
                _a[Keys.left] = reverse ? increment : decrement,
                _a[Keys.right] = reverse ? decrement : increment,
                _a[Keys.down] = decrement,
                _a[Keys.up] = increment,
                _a[Keys.home] = function (_a) {
                    var min = _a.min;
                    return min;
                },
                _a[Keys.end] = function (_a) {
                    var max = _a.max;
                    return max;
                },
                _a;
            var _a;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     * Called when the status of the component changes to or from `disabled`.
     * Depending on the value, it enables or disables the appropriate DOM element.
     *
     * @param isDisabled
     */
    SliderComponent.prototype.setDisabledState = function (isDisabled) {
        this.disabled = isDisabled;
    };
    /**
     * @hidden
     */
    SliderComponent.prototype.handleFocus = function () {
        this.focused = true;
        this.onFocus.emit();
    };
    /**
     * @hidden
     */
    SliderComponent.prototype.handleBlur = function () {
        this.focused = false;
        this.ngTouched();
        this.onBlur.emit();
    };
    /**
     * @hidden
     */
    SliderComponent.prototype.keydown = function (event) {
        this.onKeyDown(event);
    };
    SliderComponent.prototype.ngOnInit = function () {
        this.renderer.removeAttribute(this.hostElement, "tabindex");
    };
    /**
     * Focuses the Slider component.
     *
     * @example
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="slider.focus()">Focus</button>
     *  <kendo-slider #slider></kendo-slider>
     * `
     * })
     * class AppComponent { }
     * ```
     */
    SliderComponent.prototype.focus = function () {
        if (!this.wrapper) {
            return;
        }
        this.wrapper.nativeElement.focus();
    };
    /**
     * Blurs the Slider component.
     */
    SliderComponent.prototype.blur = function () {
        if (!this.wrapper) {
            return;
        }
        this.wrapper.nativeElement.blur();
    };
    SliderComponent.prototype.ngOnChanges = function (changes) {
        if (isChanged('value', changes)) {
            this.sizeComponent(false);
        }
    };
    SliderComponent.prototype.ngAfterViewInit = function () {
        var _this = this;
        if (!isDocumentAvailable()) {
            return;
        }
        if (this.showButtons) {
            this.increaseButtonSubscription = this.setValueChangeInterval(this.increaseButton.nativeElement, function () { return _this.increaseValue(); });
            this.decreaseButtonSubscription = this.setValueChangeInterval(this.decreaseButton.nativeElement, function () { return _this.decreaseValue(); });
        }
        this.sizeComponent(false);
        if (this.ticks) {
            this.ticks.tickElements
                .changes
                .subscribe(function () { return _this.sizeComponent(false); });
        }
    };
    SliderComponent.prototype.ngOnDestroy = function () {
        this.decreaseButtonSubscription.unsubscribe();
        this.increaseButtonSubscription.unsubscribe();
    };
    Object.defineProperty(SliderComponent.prototype, "incrementMessage", {
        /**
         * @hidden
         */
        get: function () {
            return this.incrementTitle || this.localizationService.get('increment');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "decrementMessage", {
        /**
         * @hidden
         */
        get: function () {
            return this.decrementTitle || this.localizationService.get('decrement');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SliderComponent.prototype, "dragHandleMessage", {
        /**
         * @hidden
         */
        get: function () {
            return this.dragHandleTitle || this.localizationService.get('dragHandle');
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    SliderComponent.prototype.onWrapClick = function (args) {
        var target = args.target;
        if (!(isButton(target) || isButton(target.parentNode))) {
            var value = eventValue(args, this.track.nativeElement, this.getProps());
            this.changeValue(value);
        }
    };
    /**
     * @hidden
     */
    SliderComponent.prototype.handleDragPress = function (args) {
        if (args.originalEvent) {
            args.originalEvent.preventDefault();
        }
        this.focus();
    };
    /**
     * @hidden
     */
    SliderComponent.prototype.onHandleDrag = function (args) {
        this.dragging = true;
        this.changeValue(eventValue(args, this.track.nativeElement, this.getProps()));
    };
    /**
     * @hidden
     */
    SliderComponent.prototype.onKeyDown = function (e) {
        var options = this.getProps();
        var disabled = options.disabled, max = options.max, min = options.min;
        var handler = this.keyBinding[e.keyCode];
        if (handler && !disabled) {
            var value = handler(options);
            this.changeValue(Util.trimValue(max, min, value));
            e.preventDefault();
        }
    };
    /**
     * @hidden
     */
    SliderComponent.prototype.onHandleRelease = function () {
        this.dragging = false; //needed for animation
    };
    //ngModel binding
    /**
     * @hidden
     */
    SliderComponent.prototype.writeValue = function (value) {
        this.value = value;
        this.sizeComponent(true);
    };
    /**
     * @hidden
     */
    SliderComponent.prototype.registerOnChange = function (fn) {
        this.ngChange = fn;
    };
    /**
     * @hidden
     */
    SliderComponent.prototype.registerOnTouched = function (fn) {
        this.ngTouched = fn;
    };
    /**
     * @hidden
     */
    SliderComponent.prototype.changeValue = function (value) {
        this.value = value;
        this.ngChange(value);
        this.valueChange.emit(value);
        this.sizeComponent(true);
    };
    /**
     * @hidden
     */
    SliderComponent.prototype.sizeComponent = function (animate) {
        if (!isDocumentAvailable()) {
            return;
        }
        var wrapper = this.wrapper.nativeElement;
        var props = this.getProps();
        var model = new SliderModel(props, wrapper, this.track.nativeElement);
        model.resizeTrack();
        if (this.ticks) {
            model.resizeTicks(this.ticksContainer.nativeElement, this.ticks.tickElements.map(function (element) { return element.nativeElement; }));
        }
        this.handleAnimation(animate); //first time the widget is initialized the selection should not be animated
        model.positionHandle(this.draghandle.nativeElement);
        model.positionSelection(this.draghandle.nativeElement, this.sliderSelection.nativeElement);
        if (this.fixedTickWidth) {
            model.resizeWrapper();
        }
    };
    SliderComponent.prototype.setValueChangeInterval = function (element, callback) {
        var _this = this;
        var mousedown = fromEvent(element, 'mousedown');
        var mouseup = fromEvent(element, 'mouseup');
        var mouseout = fromEvent(element, 'mouseout');
        var subscription = mousedown.pipe(filter(function (e) { return e.button === 0; }), filter(function () { return !_this.disabled; }), concatMap(function () {
            return interval(150).pipe(startWith(-1), takeUntil(merge(mouseup, mouseout)));
        })).subscribe(function () {
            _this.focus();
            callback();
        });
        return subscription;
    };
    SliderComponent.prototype.handleAnimation = function (animate) {
        var transition = '';
        if (!animate) {
            transition = 'none';
        }
        this.draghandle.nativeElement.style.transition = transition;
        this.sliderSelection.nativeElement.style.transition = transition;
    };
    SliderComponent.prototype.getProps = function () {
        return {
            buttons: this.showButtons,
            disabled: this.disabled,
            fixedTickWidth: this.fixedTickWidth,
            max: this.max,
            min: this.min,
            reverse: this.reverse,
            smallStep: this.smallStep,
            value: Util.trimValue(this.max, this.min, this.value),
            vertical: this.vertical,
            rtl: this.rtl
        };
    };
    SliderComponent.decorators = [
        { type: Component, args: [{
                    exportAs: 'kendoSlider',
                    providers: [
                        LocalizationService,
                        { provide: L10N_PREFIX, useValue: 'kendo.slider' },
                        { multi: true, provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(function () { return SliderComponent; }) } /* tslint:disable-line */
                    ],
                    selector: 'kendo-slider',
                    template: "\n        <ng-container kendoSliderLocalizedMessages\n            i18n-increment=\"kendo.slider.increment|The title of the **Increase** button of the Slider.\"\n            increment=\"increment\"\n            i18n-decrement=\"kendo.slider.decrement|The title of the **Decrease** button of the Slider.\"\n            decrement=\"decrement\"\n            i18n-dragHandle=\"kendo.slider.dragHandle|The title of the drag handle of the Slider.\"\n            dragHandle=\"Drag\"\n        >\n\n        <div class=\"k-slider-wrap\" #wrap\n            [id]=\"id\"\n            [class.k-slider-buttons]=\"showButtons\"\n            [class.k-slider-topleft]=\"tickPlacement === 'before'\"\n            [class.k-slider-bottomright]=\"tickPlacement === 'after'\"\n            (click)=\"ifEnabled(onWrapClick, $event)\"\n            [attr.tabindex]=\"(this.disabled ? undefined : tabIndex)\"\n            (focus)=\"handleFocus()\"\n            (blur)=\"handleBlur()\"\n            >\n            <a\n                #decreaseButton\n                *ngIf=\"showButtons\"\n                class=\"k-button k-button-decrease\"\n                [title]=\"decrementMessage\"\n                [attr.aria-label]=\"decrementMessage\"\n            >\n                <span\n                    [class.k-icon]=\"true\"\n                    [class.k-i-arrow-w]=\"!vertical\"\n                    [class.k-i-arrow-s]=\"vertical\"\n                >\n                </span>\n            </a>\n            <a\n                *ngIf=\"showButtons\"\n                #increaseButton\n                class=\"k-button k-button-increase\"\n                [title]=\"incrementMessage\"\n                [attr.aria-label]=\"incrementMessage\"\n            >\n                <span\n                    [class.k-icon]=\"true\"\n                    [class.k-i-arrow-e]=\"!vertical\"\n                    [class.k-i-arrow-n]=\"vertical\"\n                >\n                </span>\n            </a>\n            <ul kendoSliderTicks\n                #ticks\n                *ngIf=\"tickPlacement !== 'none'\"\n                [tickTitle]=\"title\"\n                [vertical]=\"vertical\"\n                [step]=\"smallStep\"\n                [min]=\"min\"\n                [max]=\"max\"\n            >\n            </ul>\n        <div #track\n            class=\"k-slider-track\"\n            >\n            <div #sliderSelection\n                [class.k-slider-selection]=\"true\"\n                [class.k-pressed]=\"dragging\"\n                >\n            </div>\n                <a #draghandle\n                    [class.k-draghandle]=\"true\"\n                    [class.k-pressed]=\"dragging\"\n                    [title]=\"dragHandleMessage\"\n                    kendoDraggable\n                    (kendoPress)=\"ifEnabled(handleDragPress ,$event)\"\n                    (kendoDrag)=\"ifEnabled(onHandleDrag ,$event)\"\n                    (kendoRelease)=\"ifEnabled(onHandleRelease, $event)\"\n                >Drag</a>\n            </div>\n\n            <kendo-resize-sensor (resize)=\"sizeComponent(false)\"></kendo-resize-sensor>\n        </div>\n\n  "
                },] },
    ];
    /** @nocollapse */
    SliderComponent.ctorParameters = function () { return [
        { type: LocalizationService, },
        { type: Renderer2, },
        { type: ElementRef, },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [RTL,] },] },
    ]; };
    SliderComponent.propDecorators = {
        'id': [{ type: Input },],
        'incrementTitle': [{ type: Input },],
        'decrementTitle': [{ type: Input },],
        'showButtons': [{ type: Input },],
        'tickPlacement': [{ type: Input },],
        'title': [{ type: Input },],
        'dragHandleTitle': [{ type: Input },],
        'vertical': [{ type: Input },],
        'min': [{ type: Input },],
        'max': [{ type: Input },],
        'smallStep': [{ type: Input },],
        'fixedTickWidth': [{ type: Input },],
        'disabled': [{ type: Input },],
        'value': [{ type: Input },],
        'tabindex': [{ type: Input },],
        'tabIndex': [{ type: Input },],
        'onFocus': [{ type: Output, args: ['focus',] },],
        'onBlur': [{ type: Output, args: ['blur',] },],
        'valueChange': [{ type: Output },],
        'wrapper': [{ type: ViewChild, args: ['wrap',] },],
        'track': [{ type: ViewChild, args: ['track',] },],
        'draghandle': [{ type: ViewChild, args: ['draghandle',] },],
        'sliderSelection': [{ type: ViewChild, args: ['sliderSelection',] },],
        'ticksContainer': [{ type: ViewChild, args: ['ticks', { read: ElementRef },] },],
        'ticks': [{ type: ViewChild, args: ['ticks',] },],
        'decreaseButton': [{ type: ViewChild, args: ['decreaseButton',] },],
        'increaseButton': [{ type: ViewChild, args: ['increaseButton',] },],
        'direction': [{ type: HostBinding, args: ['attr.dir',] },],
        'horizontalClass': [{ type: HostBinding, args: ['class.k-slider-horizontal',] },],
        'verticalClass': [{ type: HostBinding, args: ['class.k-slider-vertical',] },],
        'sliderClass': [{ type: HostBinding, args: ['class.k-slider',] },],
        'transitionsClass': [{ type: HostBinding, args: ['class.k-slider-transitions',] },],
        'widgetClass': [{ type: HostBinding, args: ['class.k-widget',] },],
        'stateDefaultClass': [{ type: HostBinding, args: ['class.k-state-default',] },],
        'disabledClass': [{ type: HostBinding, args: ['class.k-state-disabled',] },],
        'focusedClass': [{ type: HostBinding, args: ['class.k-state-focused',] },],
        'ariaDisabled': [{ type: HostBinding, args: ['attr.aria-disabled',] },],
        'ariaMin': [{ type: HostBinding, args: ['attr.aria-valuemin',] },],
        'ariaMax': [{ type: HostBinding, args: ['attr.aria-valuemax',] },],
        'ariaValue': [{ type: HostBinding, args: ['attr.aria-valuenow',] },],
        'keydown': [{ type: HostListener, args: ['keydown', ['$event'],] },],
    };
    return SliderComponent;
}());
export { SliderComponent };
